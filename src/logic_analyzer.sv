
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module logic_analyzer(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_SCK,
	output		          		ADC_SDI,
	input 		          		ADC_SDO,

	//////////// ARDUINO //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HDMI //////////
	inout 		          		HDMI_I2C_SCL,
	inout 		          		HDMI_I2C_SDA,
	inout 		          		HDMI_I2S,
	inout 		          		HDMI_LRCLK,
	inout 		          		HDMI_MCLK,
	inout 		          		HDMI_SCLK,
	output		          		HDMI_TX_CLK,
	output		          		HDMI_TX_DE,
	output		    [23:0]		HDMI_TX_D,
	output		          		HDMI_TX_HS,
	input 		          		HDMI_TX_INT,
	output		          		HDMI_TX_VS,

	//////////// HPS //////////
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// GPIO_0, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_0,

	//////////// GPIO_1, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1
);

assign rst = ~KEY[0];

wire clk;
wire clk_div8;

wire [7:0] [31:0] wr_states;

wire         mapped_wr_valid;
wire [255:0] mapped_wr_data;

wire         mem_wr_valid;
wire [255:0] mem_wr_data;

pll pll(
	.refclk(FPGA_CLK1_50),
	.rst(rst),
	.outclk_0(clk),
	.outclk_1(clk_div8),
	.locked(0)
);

capture_frontend frontend (
	.rst(rst),
	.clk(clk),
	.channels(GPIO_0[31:0]),
	.clk_div8(clk_div8),
	.wr_states(wr_states)
);

//wire o_valid;
//assign clk_div8 = !o_valid;
//
//frontend fr (
//	.clk(clk),
//	.reset(rst),
//	.inin(GPIO_0[1:0]),
//	.o_valid(o_valid),
//	.outout({wr_states[1], wr_states[0]})
//);

capture_channel_mapper channel_mapper (
	.rst(rst),
	.clk(clk_div8),
	.channels(SW[3:1]),
	.wr_states(wr_states),
	.out_valid(mapped_wr_valid),
	.out_data(mapped_wr_data)
);

//capture_compressor compressor (
//	.rst(rst),
//	.clk(clk_div8),
//	.in_valid(mapped_wr_valid),
//	.in_data(mapped_wr_data),
//	.out_valid(mem_wr_valid),
//	.out_data(mem_wr_data)
//);

assign mem_wr_valid = mapped_wr_valid;
assign mem_wr_data = mapped_wr_data;

wire mem_clk;

wire  [26:0] sdram_address;
wire   [7:0] sdram_burstcount;
wire         sdram_waitrequest;
wire         sdram_read;
wire [255:0] sdram_readdata;
wire         sdram_readdatavalid;
wire         sdram_write;
wire [255:0] sdram_writedata;
wire  [31:0] sdram_byteenable;

wire   [4:0] h2f_lw_address;
wire         h2f_lw_burstcount;
wire         h2f_lw_waitrequest;
wire         h2f_lw_read;
wire  [31:0] h2f_lw_readdata;
wire         h2f_lw_readdatavalid;
wire         h2f_lw_write;
wire  [31:0] h2f_lw_writedata;
wire   [3:0] h2f_lw_byteenable;

hps u0 (
	.clk_clk                       (FPGA_CLK1_50),                //              clk.clk

	.mem_clk_clk                   (mem_clk),                     //          mem_clk.clk

	.memory_mem_a                  (HPS_DDR3_ADDR),               //           memory.mem_a
	.memory_mem_ba                 (HPS_DDR3_BA),                 //                 .mem_ba
	.memory_mem_ck                 (HPS_DDR3_CK_P),               //                 .mem_ck
	.memory_mem_ck_n               (HPS_DDR3_CK_N),               //                 .mem_ck_n
	.memory_mem_cke                (HPS_DDR3_CKE),                //                 .mem_cke
	.memory_mem_cs_n               (HPS_DDR3_CS_N),               //                 .mem_cs_n
	.memory_mem_ras_n              (HPS_DDR3_RAS_N),              //                 .mem_ras_n
	.memory_mem_cas_n              (HPS_DDR3_CAS_N),              //                 .mem_cas_n
	.memory_mem_we_n               (HPS_DDR3_WE_N),               //                 .mem_we_n
	.memory_mem_reset_n            (HPS_DDR3_RESET_N),            //                 .mem_reset_n
	.memory_mem_dq                 (HPS_DDR3_DQ),                 //                 .mem_dq
	.memory_mem_dqs                (HPS_DDR3_DQS_P),              //                 .mem_dqs
	.memory_mem_dqs_n              (HPS_DDR3_DQS_N),              //                 .mem_dqs_n
	.memory_mem_odt                (HPS_DDR3_ODT),                //                 .mem_odt
	.memory_mem_dm                 (HPS_DDR3_DM),                 //                 .mem_dm
	.memory_oct_rzqin              (HPS_DDR3_RZQ),                //                 .oct_rzqin

	.f2h_sdram0_data_address       (sdram_address),               //  f2h_sdram0_data.address
	.f2h_sdram0_data_burstcount    (sdram_burstcount),            //                 .burstcount
	.f2h_sdram0_data_waitrequest   (sdram_waitrequest),           //                 .waitrequest
	.f2h_sdram0_data_read          (sdram_read),                  //                 .read
	.f2h_sdram0_data_readdata      (sdram_readdata),              //                 .readdata
	.f2h_sdram0_data_readdatavalid (sdram_readdatavalid),         //                 .readdatavalid
	.f2h_sdram0_data_write         (sdram_write),                 //                 .write
	.f2h_sdram0_data_writedata     (sdram_writedata),             //                 .writedata
	.f2h_sdram0_data_byteenable    (sdram_byteenable),            //                 .byteenable

	.h2f_lw_address                (h2f_lw_address),              //           h2f_lw.address
	.h2f_lw_burstcount             (h2f_lw_burstcount),           //                 .burstcount
	.h2f_lw_waitrequest            (h2f_lw_waitrequest),          //                 .waitrequest
	.h2f_lw_read                   (h2f_lw_read),                 //                 .read
	.h2f_lw_readdata               (h2f_lw_readdata),             //                 .readdata
	.h2f_lw_readdatavalid          (h2f_lw_readdatavalid),        //                 .readdatavalid
	.h2f_lw_write                  (h2f_lw_write),                //                 .write
	.h2f_lw_writedata              (h2f_lw_writedata),            //                 .writedata
	.h2f_lw_byteenable             (h2f_lw_byteenable),           //                 .byteenable

	.capture_clk_clk               (ARDUINO_IO[7])
);

//wire [26:0] sdram_address_full;
//assign sdram_address = sdram_address_full & (32'h2FFFFFFF >> 5) | (32'h20000000 >> 5);

wire fail;
assign fail = sdram_address < (32'h20000000 >> 5) || sdram_address > (32'h40000000 >> 5);

assign LED[6] = fail;

wire write_full;
assign LED[4] = write_full;

//reg[48:0] test_ctr1;
//reg[32:0] test_ctr2;
//
//assign LED[7] = test_ctr1[25];
//
//always @(posedge FPGA_CLK1_50) begin
//	test_ctr1 <= test_ctr1 + 1;
//end
//
//always @(posedge FPGA_CLK1_50, posedge rst) begin
//	if(rst) begin
//		test_ctr2 <= 0;
//	end else begin
//		if(!write_full) begin
//			test_ctr2 <= test_ctr2 + 1;
//		end
//	end
//end

sdram_interface sdram_iface(
	.rst(rst),
	.wr_clk(clk_div8),
	.wr_data_en(~write_full && mem_wr_valid),
	.wr_data(mem_wr_data),
	.wr_full(write_full),

	.fill_launch(~KEY[1]),
	.fill_terminate(SW[0]),
	.fill_running(LED[5]),
	.fill_addr_start(32'h20000000 >> 5),
	.fill_addr_end(32'h3fffffff >> 5),

	.sdram_clk           (mem_clk),
	.sdram_address       (sdram_address),
	.sdram_burstcount    (sdram_burstcount),
	.sdram_waitrequest   (sdram_waitrequest),
	.sdram_read          (sdram_read),
	.sdram_readdata      (sdram_readdata),
	.sdram_readdatavalid (sdram_readdatavalid),
	.sdram_write         (sdram_write),
	.sdram_writedata     (sdram_writedata),
	.sdram_byteenable    (sdram_byteenable)
);

wire        reg_clk       [16];
wire        reg_write     [16];
wire [31:0] reg_readdata  [16];
wire [31:0] reg_writedata;

memory_mapped_regs #(.ADDR_SIZE(4)) mm (
	.rst(rst),

	.mm_clk           (mem_clk),
	.mm_address       (h2f_lw_address),
	.mm_burstcount    (h2f_lw_burstcount),
	.mm_waitrequest   (h2f_lw_waitrequest),
	.mm_read          (h2f_lw_read),
	.mm_readdata      (h2f_lw_readdata),
	.mm_readdatavalid (h2f_lw_readdatavalid),
	.mm_write         (h2f_lw_write),
	.mm_writedata     (h2f_lw_writedata),
	.mm_byteenable    (h2f_lw_byteenable),

	.reg_clk        (reg_clk),
	.reg_write      (reg_write),
	.reg_readdata   (reg_readdata),
	.reg_writedata  (reg_writedata)
);

assign reg_clk[0] = ARDUINO_IO[7];

reg [31:0] ctr;

assign reg_readdata[0] = ctr;

always @(posedge ARDUINO_IO[7]) begin
	if(reg_write[0]) begin
		ctr <= reg_writedata;
	end else begin
		ctr <= ctr + 1;
	end
end

assign reg_clk[3] = ARDUINO_IO[7];

reg [31:0] shr;

assign reg_readdata[3] = shr;

always @(posedge ARDUINO_IO[7]) begin
	if(reg_write[3]) begin
		shr <= reg_writedata;
	end else begin
		shr <= {shr[30:0], shr[31]};
	end
end

endmodule
