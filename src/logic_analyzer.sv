
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module logic_analyzer(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_SCK,
	output		          		ADC_SDI,
	input 		          		ADC_SDO,

	//////////// ARDUINO //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HDMI //////////
	inout 		          		HDMI_I2C_SCL,
	inout 		          		HDMI_I2C_SDA,
	inout 		          		HDMI_I2S,
	inout 		          		HDMI_LRCLK,
	inout 		          		HDMI_MCLK,
	inout 		          		HDMI_SCLK,
	output		          		HDMI_TX_CLK,
	output		          		HDMI_TX_DE,
	output		    [23:0]		HDMI_TX_D,
	output		          		HDMI_TX_HS,
	input 		          		HDMI_TX_INT,
	output		          		HDMI_TX_VS,

	//////////// HPS //////////
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// GPIO_0, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_0,

	//////////// GPIO_1, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1
);

assign rst = ~KEY[0];

wire sample_clk;
wire data_clk;
wire sdram_clk;
wire hps_clk;
wire adc_clk;
assign hps_clk = FPGA_CLK1_50;

wire  [26:0] sdram_address;
wire   [7:0] sdram_burstcount;
wire         sdram_waitrequest;
wire         sdram_read;
wire [255:0] sdram_readdata;
wire         sdram_readdatavalid;
wire         sdram_write;
wire [255:0] sdram_writedata;
wire  [31:0] sdram_byteenable;

wire   [5:0] h2f_lw_address;
wire         h2f_lw_burstcount;
wire         h2f_lw_waitrequest;
wire         h2f_lw_read;
wire  [31:0] h2f_lw_readdata;
wire         h2f_lw_readdatavalid;
wire         h2f_lw_write;
wire  [31:0] h2f_lw_writedata;
wire   [3:0] h2f_lw_byteenable;

hps u0 (
	.clk_clk                       (hps_clk),                     //              clk.clk

	.memory_mem_a                  (HPS_DDR3_ADDR),               //           memory.mem_a
	.memory_mem_ba                 (HPS_DDR3_BA),                 //                 .mem_ba
	.memory_mem_ck                 (HPS_DDR3_CK_P),               //                 .mem_ck
	.memory_mem_ck_n               (HPS_DDR3_CK_N),               //                 .mem_ck_n
	.memory_mem_cke                (HPS_DDR3_CKE),                //                 .mem_cke
	.memory_mem_cs_n               (HPS_DDR3_CS_N),               //                 .mem_cs_n
	.memory_mem_ras_n              (HPS_DDR3_RAS_N),              //                 .mem_ras_n
	.memory_mem_cas_n              (HPS_DDR3_CAS_N),              //                 .mem_cas_n
	.memory_mem_we_n               (HPS_DDR3_WE_N),               //                 .mem_we_n
	.memory_mem_reset_n            (HPS_DDR3_RESET_N),            //                 .mem_reset_n
	.memory_mem_dq                 (HPS_DDR3_DQ),                 //                 .mem_dq
	.memory_mem_dqs                (HPS_DDR3_DQS_P),              //                 .mem_dqs
	.memory_mem_dqs_n              (HPS_DDR3_DQS_N),              //                 .mem_dqs_n
	.memory_mem_odt                (HPS_DDR3_ODT),                //                 .mem_odt
	.memory_mem_dm                 (HPS_DDR3_DM),                 //                 .mem_dm
	.memory_oct_rzqin              (HPS_DDR3_RZQ),                //                 .oct_rzqin

	.f2h_sdram0_clk_clk            (sdram_clk),                   //   f2h_sdram0_clk.clk
	.f2h_sdram0_data_address       (sdram_address),               //  f2h_sdram0_data.address
	.f2h_sdram0_data_burstcount    (sdram_burstcount),            //                 .burstcount
	.f2h_sdram0_data_waitrequest   (sdram_waitrequest),           //                 .waitrequest
	.f2h_sdram0_data_read          (sdram_read),                  //                 .read
	.f2h_sdram0_data_readdata      (sdram_readdata),              //                 .readdata
	.f2h_sdram0_data_readdatavalid (sdram_readdatavalid),         //                 .readdatavalid
	.f2h_sdram0_data_write         (sdram_write),                 //                 .write
	.f2h_sdram0_data_writedata     (sdram_writedata),             //                 .writedata
	.f2h_sdram0_data_byteenable    (sdram_byteenable),            //                 .byteenable

	.h2f_lw_address                (h2f_lw_address),              //           h2f_lw.address
	.h2f_lw_burstcount             (h2f_lw_burstcount),           //                 .burstcount
	.h2f_lw_waitrequest            (h2f_lw_waitrequest),          //                 .waitrequest
	.h2f_lw_read                   (h2f_lw_read),                 //                 .read
	.h2f_lw_readdata               (h2f_lw_readdata),             //                 .readdata
	.h2f_lw_readdatavalid          (h2f_lw_readdatavalid),        //                 .readdatavalid
	.h2f_lw_write                  (h2f_lw_write),                //                 .write
	.h2f_lw_writedata              (h2f_lw_writedata),            //                 .writedata
	.h2f_lw_byteenable             (h2f_lw_byteenable),           //                 .byteenable

	.clk_capture_clk               (sample_clk),                  //          clk_adc.clk
	.clk_adc_clk                   (adc_clk)                      //      clk_capture.clk
);

wire        reg_clk       [16];
wire        reg_write     [16];
wire [31:0] reg_readdata  [16];
wire [31:0] reg_writedata;

memory_mapped_regs #(.ADDR_SIZE(4)) mm (
	.rst(rst),

	.mm_clk           (hps_clk),
	.mm_address       (h2f_lw_address),
	.mm_burstcount    (h2f_lw_burstcount),
	.mm_waitrequest   (h2f_lw_waitrequest),
	.mm_read          (h2f_lw_read),
	.mm_readdata      (h2f_lw_readdata),
	.mm_readdatavalid (h2f_lw_readdatavalid),
	.mm_write         (h2f_lw_write),
	.mm_writedata     (h2f_lw_writedata),
	.mm_byteenable    (h2f_lw_byteenable),

	.reg_clk        (reg_clk),
	.reg_write      (reg_write),
	.reg_readdata   (reg_readdata),
	.reg_writedata  (reg_writedata)
);

//  0: Register CTRL (RW)
// [26:24] - trig mode
//             0 - always
//             1 - rising edge
//             2 - falling edge
//             3 - both edges
//             4 - high
//             5 - low
//         other - never
// [23:19] - trig channel
// [18:16] - num channels
//      2  - reset adc
//      1  - reset digital frontend
//      0  - reset sdram_iface
struct packed {
	reg [ 4:0] __reserved1;
	reg [ 2:0] trig_mode;
	reg [ 4:0] trig_channel;
	reg [ 2:0] num_channel;
	reg [12:0] __reserved0;
	reg        rst_analog;
	reg        rst_digital;
	reg        rst_sdram;
} reg_CTRL;
assign reg_readdata[0] = reg_CTRL;
assign reg_clk[0] = hps_clk;
always @(posedge hps_clk) begin
	if(reg_write[0]) begin
		reg_CTRL <= reg_writedata;
	end
end

//  1: Register INFO_RUN (R)
//      17  - fill_wrapped
//      16  - triggered
//  [15: 8] - trig_sample 
//       2  - terminate
//       1  - launch
//       0  - running
struct packed {
	logic [13:0] __reserved1;
	logic        fill_wrapped;
	logic        triggered;
	logic [ 7:0] trig_sample;
	logic [ 4:0] __reserved0;
	reg          terminate;
	reg          launch;
	logic        running;
} reg_INFO_RUN;
assign reg_readdata[1] = reg_INFO_RUN;
assign reg_clk[1] = sdram_clk;
always @(posedge sdram_clk) begin
	reg_INFO_RUN.launch = 0;
	if(reg_INFO_RUN.terminate && !reg_INFO_RUN.running) begin
		reg_INFO_RUN.terminate = 0;
	end
	if(reg_write[1]) begin
		if(reg_writedata[1]) begin
			reg_INFO_RUN.launch = 1;
		end
		if(reg_writedata[2]) begin
			reg_INFO_RUN.terminate = 1;
		end
	end
end

//  2: Register TRIG_COND_MATCH (RW)
// [31: 0] - match
reg [31:0] reg_TRIG_COND_MATCH;
assign reg_readdata[2] = reg_TRIG_COND_MATCH;
assign reg_clk[2] = data_clk;
always @(posedge data_clk) begin
	if(reg_write[2]) begin
		reg_TRIG_COND_MATCH <= reg_writedata;
	end
end

//  3: Register TRIG_COND_MASK (RW)
// [31: 0] - mask
reg [31:0] reg_TRIG_COND_MASK;
assign reg_readdata[3] = reg_TRIG_COND_MASK;
assign reg_clk[3] = data_clk;
always @(posedge data_clk) begin
	if(reg_write[3]) begin
		reg_TRIG_COND_MASK <= reg_writedata;
	end
end

//  4: Register SAMPLE_D_COUNT (R)
// [63: 0] - number of digital samples collected
reg [63:0] reg_SAMPLE_D_COUNT;
assign reg_clk[4:5] = '{data_clk, data_clk};
assign reg_readdata[4:5] = '{reg_SAMPLE_D_COUNT[31:0], reg_SAMPLE_D_COUNT[63:32]};

//  6: Register SAMPLE_D_LIMIT (RW)
// [63: 0] - maximum number of digital samples after trigger
reg [63:0] reg_SAMPLE_D_LIMIT;
assign reg_clk[6:7] = '{data_clk, data_clk};
assign reg_readdata[6:7] = '{reg_SAMPLE_D_LIMIT[31:0], reg_SAMPLE_D_LIMIT[63:32]};
always @(posedge data_clk) begin
	if(reg_write[7]) begin
		reg_SAMPLE_D_LIMIT[63:32] <= reg_writedata;
	end
	if(reg_write[6]) begin
		reg_SAMPLE_D_LIMIT[31:0] <= reg_writedata;
	end
end

//  8: Register ENTRY_ADDR (R)
//     31  - if address wrapped when writing to memory
// [30: 0] - address of last entry header
wire [31:0] reg_ENTRY_ADDR;
assign reg_clk[8] = sdram_clk;
assign reg_readdata[8] = reg_ENTRY_ADDR;

// 9: Register ENTRY_LIMIT (RW)
// [31: 0] - maximum number of entries after trigger
reg [31:0] reg_ENTRY_LIMIT;
assign reg_clk[9] = sdram_clk;
assign reg_readdata[9] = reg_ENTRY_LIMIT;
always @(posedge sdram_clk) begin
	if(reg_write[9]) begin
		reg_ENTRY_LIMIT <= reg_writedata;
	end
end

// 10: Register TRIG_ADDR (R)
// [31: 0] - the entry where trigger happened
wire [31:0] reg_TRIG_ADDR;
assign reg_clk[10] = sdram_clk;
assign reg_readdata[10] = reg_TRIG_ADDR;

// 11: Register ADC_CONFIG_1 (RW)
// [29:25] - cfg 5
// [24:20] - cfg 4
// [19:15] - cfg 3
// [14:10] - cfg 2
// [ 9: 5] - cfg 1
// [ 4: 0] - cfg 0
reg [31:0] reg_ADC_CONFIG_1;
assign reg_clk[11] = adc_clk;
assign reg_readdata[11] = reg_ADC_CONFIG_1;
always @(posedge adc_clk) begin
	if(reg_write[11]) begin
		reg_ADC_CONFIG_1 <= reg_writedata;
	end
end

// 12: Register ADC_CONFIG_2 (RW)
// [18:16] - number of configs
// [ 9: 5] - cfg 7
// [ 4: 0] - cfg 6
reg [31:0] reg_ADC_CONFIG_2;
assign reg_clk[12] = adc_clk;
assign reg_readdata[12] = reg_ADC_CONFIG_2;
always @(posedge adc_clk) begin
	if(reg_write[12]) begin
		reg_ADC_CONFIG_2 <= reg_writedata;
	end
end

wire [7:0] [4:0] adc_config;
assign adc_config[0] = reg_ADC_CONFIG_1[ 4: 0];
assign adc_config[1] = reg_ADC_CONFIG_1[ 9: 5];
assign adc_config[2] = reg_ADC_CONFIG_1[14:10];
assign adc_config[3] = reg_ADC_CONFIG_1[19:15];
assign adc_config[4] = reg_ADC_CONFIG_1[24:20];
assign adc_config[5] = reg_ADC_CONFIG_1[29:25];
assign adc_config[6] = reg_ADC_CONFIG_2[ 4: 0];
assign adc_config[7] = reg_ADC_CONFIG_2[ 9: 5];

wire [2:0] adc_config_cnt;
assign adc_config_cnt = reg_ADC_CONFIG_2[18:16];

// 13: Register SAMPLE_A_COUNT (R)
// [31: 0] - number of analog samples collected
reg [31:0] reg_SAMPLE_A_COUNT;
assign reg_clk[13] = adc_clk;
assign reg_readdata[13] = reg_SAMPLE_A_COUNT;

// 14: Register CLK_CNT_SAMPLE (R)
// [31: 0] - clk rate in kHz
reg [31:0] reg_CLK_CNT_SAMPLE;
assign reg_clk[14] = FPGA_CLK1_50;
clock_monitor clk_mon_sample(
	.rst(rst),
	.clk(sample_clk),
	.ref_clk(FPGA_CLK1_50),
	.count(reg_readdata[14])
);

// 15: Register CLK_CNT_ADC (R)
// [31: 0] - clk rate in kHz
reg [31:0] reg_CLK_CNT_ADC;
assign reg_clk[15] = FPGA_CLK1_50;
clock_monitor clk_mon_data(
	.rst(rst),
	.clk(adc_clk),
	.ref_clk(FPGA_CLK1_50),
	.count(reg_readdata[15])
);

wire rst_a;
reset_sync reset_sync_a(
	.rst_in(rst | reg_CTRL.rst_analog),
	.clk(adc_clk),
	.rst_out(rst_a)
);

wire rst_d_frontend;
reset_sync reset_sync_d_frontend(
	.rst_in(rst | reg_CTRL.rst_digital),
	.clk(sample_clk),
	.rst_out(rst_d_frontend)
);

wire rst_d_pipeline;
reset_sync reset_sync_d_pipeline(
	.rst_in(rst | reg_CTRL.rst_digital),
	.clk(data_clk),
	.rst_out(rst_d_pipeline)
);

wire rst_sdram;
reset_sync reset_sdram(
	.rst_in(rst | reg_CTRL.rst_sdram),
	.clk(sdram_clk),
	.rst_out(rst_sdram)
);

wire run_a;
cdc cdc_a(
	.from  (reg_INFO_RUN.running),
	.to_rst(rst_a),
	.to_clk(adc_clk),
	.to    (run_a)
);

wire run_d;
cdc cdc_d(
	.from  (reg_INFO_RUN.running),
	.to_rst(rst_d_pipeline),
	.to_clk(data_clk),
	.to    (run_d)
);

wire [31:0] [7:0] wr_states;

capture_frontend frontend (
	.rst(rst_d_frontend),
	.clk(sample_clk),
	.channels(GPIO_0[31:0]),
	.clk_div8(data_clk),
	.wr_states(wr_states)
);

wire         d_wr_valid;
wire [255:0] d_wr_data;

wire       wr_triggered;
wire [2:0] wr_trig_pos;
wire [7:0] wr_trig_sample;

trigger trig (
	.rst(rst_d_pipeline),
	.clk(data_clk),
	.wr_states(wr_states),
	.trig_mask(reg_TRIG_MASK),
	.trig_match(reg_TRIG_MATCH),
	.trig_channel(reg_CTRL.trig_channel),
	.trig_mode(reg_CTRL.trig_mode),
	.trig_valid(wr_trig_valid),
	.trig_pos(wr_trig_pos)
);

capture_channel_mapper channel_mapper (
	.rst(rst_d_pipeline),
	.clk(data_clk),
	.channels(reg_CTRL.num_channel),
	.wr_states(wr_states),
	.trig_pos(wr_trig_pos),
	.trig_valid(wr_trig_valid),

	.out_valid(d_wr_valid),
	.out_data(d_wr_data),

	.triggered(wr_triggered),
	.trig_sample(wr_trig_sample)
);

localparam
		D_WAIT = 0,
		D_INFO_RUN = 1;

reg  [1:0] d_state;
reg        d_terminate;
reg [63:0] d_count_after_trigger;
reg        trig_latch;

always @(posedge data_clk, posedge rst_d_pipeline) begin
	if(rst_d_pipeline) begin
		reg_SAMPLE_D_COUNT <= 0;
		d_state <= D_WAIT;
		trig_latch <= 0;
		d_terminate <= 0;
		d_count_after_trigger <= 0;
	end else begin
		if(d_state == D_WAIT) begin
			if(run_d) begin
				reg_SAMPLE_D_COUNT <= 0;
				d_state <= D_INFO_RUN;
				d_count_after_trigger <= 0;
			end
			trig_latch <= 0;
			d_terminate <= 0;
		end else if(d_state == D_INFO_RUN) begin
			if(d_wr_valid) begin
				if(trig_latch) begin
					if(d_count_after_trigger == reg_SAMPLE_D_LIMIT) begin
						d_terminate <= 1;
					end else begin
						d_count_after_trigger = d_count_after_trigger + 1;
					end
				end
				reg_SAMPLE_D_COUNT <= reg_SAMPLE_D_COUNT + 1;
				if(wr_triggered && !trig_latch) begin
					trig_latch <= 1;
				end
			end
			if(!run_d) begin
				d_state <= D_WAIT;
			end
		end
	end
end

wire d_sdram_terminate;
cdc cdc_d_sdram_terminate(
	.from  (d_terminate),
	.to_rst(rst_sdram),
	.to_clk(sdram_clk),
	.to    (d_sdram_terminate)
);

adc adc(
	.rst(rst_a),
	.clk(adc_clk),
	.cfg_count(adc_config_cnt),
	.cfg_listing(adc_config),
	.sample(a_wr_data),
	.sample_valid(a_wr_valid),
	.ADC_CONVST(ADC_CONVST),
	.ADC_SCK(ADC_SCK),
	.ADC_SDI(ADC_SDI),
	.ADC_SDO(ADC_SDO)
);

localparam
		A_WAIT = 0,
		A_INFO_RUN = 1;

reg [1:0] a_state;

always @(posedge adc_clk, posedge rst_a) begin
	if(rst_a) begin
		reg_SAMPLE_A_COUNT <= 0;
		a_state <= A_WAIT;
	end else begin
		if(a_state == A_WAIT) begin
			if(run_a) begin
				reg_SAMPLE_A_COUNT <= 0;
				a_state <= A_INFO_RUN;
			end
		end else if(a_state == A_INFO_RUN) begin
			if(a_wr_valid) begin
				reg_SAMPLE_A_COUNT <= reg_SAMPLE_A_COUNT + 1;
			end
			if(!run_a) begin
				a_state <= A_WAIT;
			end
		end
	end
end

sdram_interface sdram_iface(
	.d_wr_rst(rst_d_pipeline),
	.d_wr_clk(data_clk),
	.d_wr_en(!d_wr_full && d_wr_valid && d_state == D_INFO_RUN && !d_terminate),
	.d_wr_data(d_wr_data),
	.d_wr_full(d_wr_full),
	.d_wr_trig(wr_triggered && !trig_latch),
	.d_wr_trig_sample(wr_trig_sample),

	.a_wr_rst(rst_a),
	.a_wr_clk(adc_clk),
	.a_wr_en(!a_wr_full && a_wr_valid && run_a),
	.a_wr_data(a_wr_data),
	.a_wr_full(a_wr_full),

	.fill_launch(reg_INFO_RUN.launch),
	.fill_terminate(reg_INFO_RUN.terminate | d_sdram_terminate),
	.fill_running(reg_INFO_RUN.running),
	.fill_wrapped(reg_INFO_RUN.fill_wrapped),
	.fill_last_addr(reg_ENTRY_ADDR),
	.fill_addr_start(32'h20000000 >> 5),
	.fill_addr_end(32'h3fffffff >> 5),

	.trig_entries(reg_ENTRY_LIMIT),
	.trig_sample(reg_INFO_RUN.trig_sample),
	.trig_addr(reg_TRIG_ADDR),
	.triggered(reg_INFO_RUN.triggered),

	.sdram_rst           (rst_sdram),
	.sdram_clk           (sdram_clk),
	.sdram_address       (sdram_address),
	.sdram_burstcount    (sdram_burstcount),
	.sdram_waitrequest   (sdram_waitrequest),
	.sdram_read          (sdram_read),
	.sdram_readdata      (sdram_readdata),
	.sdram_readdatavalid (sdram_readdatavalid),
	.sdram_write         (sdram_write),
	.sdram_writedata     (sdram_writedata),
	.sdram_byteenable    (sdram_byteenable)
);

endmodule
